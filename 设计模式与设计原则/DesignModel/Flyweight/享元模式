享元模式是池技术的重要实现方式 其定义为：
使用共有对象可有效地支持大量的细粒度的对象

享元模式的定义 细粒度的对象和共享对象 我们知道分配太多的对象到应用程序中将有损程序的性能 同时还能容易造成内存溢出 那
怎么避免呢？ 就是享元模式提到的共享技术
要求细粒度对象 那么不可避免的使得对象数量多且性质相近 分为俩个部分 一个是内部状态 一个是外部状态

内部状态
内部状态就是对象可共享出来的信息 存储在享元对象内部并且不会随环境改变而改变 不必直接存储在具体某个对象中 属于可被共享的
部分
外部状态
外部状态是对象得以依赖的一个标记 是随着环境改变而改变的 不可以共享的状态 它是一批对象的统一标示 是唯一的一个索引值

Flyweight--抽象享元角色
简单的说就是一个产品的抽象类 同时定义出对象的外部状态和内部状态的接口或实现
ConcreteFlyweight --具体抽象角色
具体的一个产品类 实现抽象角色定义的业务 该角色需要注意内部状态应该与环境无关 不应该出现一个操作改变了内部状态也改变了
外部状态 这是不允许的
unsharedConcreteFlyweight---不可共享的享元角色
不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象 该对象一般不会出现的享元工厂中
FlyweightFactory-----享元工厂
构造一个池容器 同时提供从池只能获得对象的方法

享元模式的目的在于运用共享技术 使得一个细粒度的对象可以共享 我们的设计模式应该是这样 多使用细粒度的对象
便于重用和重构

享元模式的优点和缺点
非常简单的模式 可以大大减少应用程序创建的对象 降低程序内部的占用 增强程序的性能 但它同时也提高了系统复杂性 需要分离出
外部状态和内部状态 而且外部状态具有固化特性 不应该随着内部状态改变而改变 否则导致系统的逻辑混乱

享元模式的使用场景
系统中存在大量的相似对象
细粒度的对象具备较接近的外部状态 而且内部状态与环境无关 也就是说对象没有特定身份
需要缓冲池的场景


注意：如果将一个对象作为map的键值 一定要确保重写了equals和hashCode方法 否则出现通过键值搜索失败的情况

自己编写的类作为外部状态 必须覆盖equals和hashcode方法 且执行效率比较低 外部状态最好还是用Java的基本类型作标识 如
String int等 可以大幅度提高效率


这里记下在网上的博客上 享元模式还有一种复杂享元的模式 这也是在本例中提到的学生考试这种情况
有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，
但是它们可以分解成单纯享元对象，而后者则可以共享。
暂且记下 有需要再详细学习