# 解释器模式

----------

> #### 运算公式分为俩类元素 一个运算元素和运算符号

解释器模式是一种按照规定语法进行解析的方案
-----
## 定义如下 给定一门语言 定义它的文法的一种表示 并定义一个解释器 该解释器使用该表示来解释语言的句子

#### AbstractExpression抽象解释器
具体的解释任务由各个实现类完成

#### TerminalExpression终结符表达式
实现与文法中的元素相关联的解释操作 通常一个解释器解释中只有一个终结者表达式 但有多个实例 对应不同的终结符

#### NonterminalExpression非终结符表达式
文法中的每条规则对应一个非终结者表达式

#### Context环境角色
具体到我们的例子是采用HashMap代替

### 解释器模式的优点
解释器是一个简单语法分析工具 它最显著的优点就是扩展性 修改语法规则只要修改相应的非终结符表达式就可以了 若扩展语法
则只要增加非终结符类就可以了

### 解释器模式的缺点
解释器模式会引起类膨胀
解释器模式采用递归调用方法
效率问题 特别是一用于解析复杂 冗长的语法时 效率是难以忍受的

### 解释器模式的使用的场景
重复发生的问题可以使用解释器模式
一个简单语法需要解释的场景 解释器模式一般来解释比较标准的字符集 比如SQL语法分析 不过这逐渐被专用工具取代

### 解释器模式的注意事项
尽量不要在重要的模块使用解释器模式 否则维护是一个很大的问题  在项目中可以使用shell JRuby Groovy等脚本语言来代替解释
器模式  弥补Java编译器语言的不足

解释器模式在实际的系统开发使用的非常少 因为它会引起效率 性能以及维护等问题 如果真的遇到“一种特定类型发生问题频率足够高”
准备使用解释器时 可以考虑一下Expression4J MESP Jep等开源解析工具包

