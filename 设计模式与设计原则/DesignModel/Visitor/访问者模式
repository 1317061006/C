访问者模式的定义
封装一些作用于某种数据结构的各元素操作 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作

Visitor抽象访问者
抽象类或接口 声明访问者可以访问哪些元素 具体到程序就是visit方法的参数定义哪些对象是可以被访问的

ConcreteVisitor 具体访问者
它影响到访问者访问一个类后该怎么干 要做什么事情

Element抽象元素
接口或抽象类  声明抽象接受哪一类访问者访问 程序上通过accept方法的参数来定义的

ConcreteElement具体元素
实现accept方法 通常是visitor(this) 基本形成了一种模式了

ObjectStruture结构对象
元素生产者 一般容纳在不同的类 不同接口的容器 如List Set map等 在项目中 一般很少抽象出这个角色

访问者模式的优点
符合单一职责原则
优秀的扩展性
灵活性非常高

访问者模式的缺点
具体元素对访问者公布细节
具体元素变更比较困难
违背了依赖倒置原则 直接依赖实现类 扩展比较麻烦

访问者模式的使用场景
一个对象结构包含很多类对象 它们有不同的接口 而你想对这些对象一些依赖于具体类的的操作 也就说是用迭代器模式已经不能胜任的场景
需要对一个对象结构中的对象进行很多不同并且不相关的操作 而你想避免这些操作“污染”的对象的类

业务规则要求遍历多个不同的对象 这本身也是访问者模式的出发点 迭代器模式只能访问同类或同种类型的接口的数据 而访问者模式
是对迭代器模式的扩充 可以遍历不同的对象 然后执行不同的操作 也就是针对访问的对象不同 执行不同的操作

遍历不同的对象进行访问 获得元素来进行自己的操作


访问者模式的扩展
多访问者的情况 我们在MultVisitor中设置俩个访问者 一个是展示表 一个汇总表
双分派 （这个我也不太清楚他在说什么）意味着执行的操作决定于请求的种类和俩个接受者的类型 它是多分派的一个特例 从这里也
可以看到java是一个支持双分派的单分派语言
