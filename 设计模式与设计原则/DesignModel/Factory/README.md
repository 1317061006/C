# 工厂方法模式

----------

## 定义一个创建对象的接口 让子类决定实例化哪一个类 工厂方法使一个类实例化延迟到子类

### 优点
- 良好的封装性 代码结构清晰  只要知道这个产品的类名（或约束字符串）就可以了  不需要理解创建的过程的艰险 降低模块间耦合
- 其次 扩展优秀 增加产品类的情况下 只要适当地修改具体工厂类或扩展一个工厂类 就可以完成“拥抱变化”
- 再次 屏蔽产品类 只需要关心产品的接口 只要接口保持不变 系统的上层模块就不要发生变化 因为产品类的实例化是由工厂类负责的

工厂方法模式是典型的解耦框架 高层模块需要知道产品的抽象类 其他的实现类都不用关心 符合迪米特法则 不需要就不用去交流
也符合依赖倒置原则 只依赖产品类的抽象 当然也符合里氏替换原则

### 工厂方法模式的使用场景
- 首先 工厂方法模式是new一个对象的替代品 所有需要生成对象的地方都可以使用
- 其次  需要灵活的 可扩展的框架时  可以考虑采用工厂方法模式

### 工厂方法的扩展
1. 缩小为简单工厂模式 去掉对工厂抽象的类  这样类图就简单了  缺点是工厂类的扩展比较困难 不符合开闭原则

2. 升级为多个工厂类  考虑到结构清晰 为每个产品定义一个创造者 然后由调用者自己去选择与哪个工厂方法关联
抽象方法已经不用再续约传递相关参数了  因为每一个具体的工厂都已经非常明确自己的职责  创建自己的负责的产品对象
好处是 创建类的职责清晰 结构简单 但是给可维护性和可扩展性带一定影响 维护时需要考虑俩个对象之间的关系
当然 在复杂的应用中一般采用多工厂的方法 然后再增加一个协调类 避免调用者与各个子工厂交流 协调者的作用是封装子工厂类
对高层模块提供统一的访问接口

3. 替代单例模式
利用反射的方式创建单例类的单例工厂类 通过获得类构造器 然后设置访问权限 生成一个对象 然后提供对外部访问  保证内存对象唯一

4. 延迟初始化 延迟初始化是指 一个对象被消耗完毕后 并不立刻释放 工厂类保持其初始状态 等待再次被使用
延迟初始化是工厂方法模式的一个扩展应用  延迟加载还可以用在对象初始化比较复杂的情况下  列如硬件访问 涉及多方面的交互
则可以通过延迟加载降低对象的产生和销毁带来的复杂性
