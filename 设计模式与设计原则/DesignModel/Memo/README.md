# 备忘录模式 

----------

## 备忘录模式的定义
在不破坏封装性的前提下 捕捉一个对象的内部状态 并在该对象之外保存这个状态 这样以后就可将该对象恢复到原先保存的状态

> 备忘录模式就是一个对象的备份模式 提供了一种程序数据的备份方法的

#### Originator发起者
记录当前时刻的内部状态 负责定义哪些属于备份访问的状态 负责创建和恢复备忘录数据
#### Memento备忘录角色
负责存储Originator发起人对象的内部状态 在需要的时候提供发起人的内部状态
#### Caretaker备忘录管理角色
对备忘录进行管理 保存和提供备忘录

### 备忘录模式的使用场景
需要保存和恢复数据的相关状态场景
提供一个可回滚的操作 比如Word中的CTRL+Z组合键 IE浏览器中的后退按钮 文件管理器上的backspace键等
需要监控的副本场景场景中
数据库连接的事务管理就是用的备忘录模式

### 备忘录模式的注意事项
备忘录的生命周期
备忘录创建处理就要在“最近”的代码中使用 要主动管理它的生命周期 建立就要使用 不使用就要立刻删除其引用 等待垃圾处理器对它的回收处理

备忘录的性能
不要在频繁建立备份的场景中使用备忘录模式 原因有二 
一是控制不了备忘录建立的对象数量 
二是大对象的建立是要耗资源的，系统的性能需要考虑

### 备忘录模式的扩展
- clone方式的备忘录
我们可以将发起者实现Cloneable接口 

实现将Memento备忘录角色Caretaker备忘录管理角色同时集合在一个类中，这其实是与备忘录模式的定义不符的 
程序精简了很多 而且高层模块的依赖也减少了 但是也需要考虑一下原型模式的深拷贝与浅拷贝的问题
在复杂的场景下会让你程序逻辑混乱  出现错误也很难追踪 因此Clone方式的备忘录模式适用于较简单的场景

- 多状态的备忘录
这里多了一个BeanUtils的类的使用 类似的功能很多工具已经提供了 比如Spring  Apache工具集commons等 可以直接提供
注意 如果要设计一个在运行期决定备份状态的框架 则建议采用AOP框架来实现 避免动态代理无谓地增加程序逻辑复杂性

- 多备份的备忘录
在需要恢复到更久以前的时候 一份备份就可能不够用了 这时候就得需要多备份才能满足 需要设计多备份的架构
检查点技术 也就是模拟在备份的时候做的戳记 系统级的备份一般是时间戳
注意 内存泄露问题 该备份一旦产生就进入内存 没有任何销毁的意向 这是非常危险的 在系统设计时 要严格限定备忘录的创建
建议增加Map的上限 否则系统很容易产生系统溢出情况

- 封装的更好一点
一个备份是完全不能被修改的 是纯洁的 避免数据污染使备份失去意义 保证只有发起人可读就好
我们需要一个空接口 然后在发起人中写一个内部类实现这个接口作为一个备份 保证只有发起人可以访问 外界的交流使用这个接口
作为公共的访问权限
