代理模式是一个使用率非常高的模式
为其他对象提供一种代理以控制对这个对象的访问

Subject抽象主题角色 是抽象类也可以是接口  是一个最普通的业务类型定义 无特殊要求
RealSubject具体主题角色 也叫做被委托角色 被代理角色 是业务逻辑的具体执行者
Proxy代理主题角色  它负责对真实角色的应用 把所有抽象主题类定义的方法限制委托给真实主题角色实现
并且在真实主题角色处理完毕前后做预处理和善后处理工作

代理模式的优点

职责清晰
真实的角色就是实现实际的业务逻辑 不用关心其他非本职责的事务 通过后期的代理完成一件事务 附带的结果就是编程简洁清晰

高扩展性
具体角色是随时都会发生变化的 只要它实现了接口 不用管如何变化
我们的代理类完全就可以在不做任何修改的情况下使用

智能化



使用场景
比如Spring AOP 只要代理用的地方都可以




代理模式的扩展

普通代理
在该模式下  调用者只知代理而不用知道真实的角色是谁 屏蔽了真实角色的变更对高层模块的影响
真实的主题角色想怎么修改就怎么修改 对高层次的模块没有任何影响 只要你项目实现了接口所对应的方法 该模式非常适合对扩展性要求
高的场合 当然 在实际项目中 一般都是通过约定禁止new一个真实的角色 这也是一个非常好的方案
（普通代理模式的约束问题，尽量对团队内的编程规范类约束 因为每一个主题类是可被重用和可维护的
使用技术约束的方式对系统是一种非常不利的因素）

强制代理
强制代理的概念就是要从这真实角色查找到代理角色 不允许直接访问真实角色 高层模块只要调用getProxy就可以访问真实角色
的所有方法 它根本就不需要产生一个代理出来 代理的管理已经由真实角色自己完成

代理也需要自己的个性
代理类不仅仅可以有自己的运算方法  通常的情况下代理的指针不一定单一 它可以组合其他的真实角色 也可以实现自己的职责
比如计算费用 代理类可以为真实角色预处理消息 过滤消息 消息转发 事后处理计消息等功能 当然一个代理类 可以代理多个真实角色
并且真实角色之间可以有耦合关系


动态代理
主要应用于AOP编程 这与静态代理有什么区别呢？都是需要实现的一个代理类 有区别 注意看父类 动态代理的主要意图就是解决
我们常说的“审计”问题 也就是横切面编程 在不改变我们已有代码结构的情况下增强或控制对象的行为
注意：要实现动态代理的首要条件是：被代理类必须实现一个接口 不过CGLIB也可以实现不需要接口也可以进行动态代理



