观察者模式也叫发布订阅模式 它是一个经常在项目中使用的模式
定义对象间一种一对多的依赖关系 使得每当一个对象改变状态 则所有依赖于它的对象都会得到通知并自动更新

Subject 被观察者
定义被观察者必须实现的职责 它必须能够动态的增加 取消观察者  它一般是抽象类或者实现类
仅仅完成作为被观察者必须实现的职责 管理观察者并通知观察者

Observer观察者
观察者接收到消息后 即进行update（更新方法）操作  对接收到的信息进行处理

ConcreteSubject具体的被观察者
定义被观察者自己的业务逻辑 同时定义对哪些事件进行通知

ConcreteObserver具体的观察者
每个观察在接收到消息后的处理反应是不同的 各个观察者有自己的处理逻辑


观察者模式的优点
观察者和被观察者之间是抽象耦合
不管是增加观察者还是被观察者都是非常容易扩展 而且在java中都实现了抽象层次的定义  在系统扩展方面更是得心应手
建立单一触发机制
根据单一职责原则 每个类的职责都是固定的单一的  形成一个触发链

观察者模式的缺点
一个被观察者 多个观察者 开发调试就会比较复杂 而且java中消息的通知默认是顺序值 一个观察者卡壳
会影响整体的执行效率 在这种情况下 一般考虑采用异步的方式

观察者模式的使用场景
关联行为场景 需要注意的是 关联是可拆分的 而不是组合关系
事件多级触发场景
跨系统的消息交换场景 如消息队列的处理机制

观察者模式的注意事项
广播链的问题
一个观察者可以有多个身份 即是观察者 也是被观察者 但是链一旦被建立 这个逻辑就比较复杂了
可维护性就很差了  根据经验建议 在一个观察者模式中最多出现一个对象即是观察者又是被观察者 也就是说
消息最多转发一次（传递俩次） 这还是比较好控制的

它与责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的 它是由相邻的俩个结点协商的消息结构
而责任链模式在消息传递过程中基本是保存消息不可变 如果要改变 也只是在原有的消息上进行修正

观察者模式的扩展
JAVA一开始就提供了一个可扩展的父类 即是java.util.Observable
还有一个java.util.Observer接口 在韩非子这个列子中 我们就使用了这种方式


项目中真实的观察者模式
观察者和被观察者之间的消息沟通
观察者中的update方法接受俩个参数 一个是被观察者 一个是DTO DTO一般是一个纯洁的JavaBean 由被观察者生成
由观察者消费
如果考虑到远程传输 一般消息以XML传输

观察者响应模式
观察者是一个比较复杂的逻辑 它要接受被观察者传递过来的信息 同时还要对他们进行逻辑处理  在一个观察者多个观察者
的情况下 性能就需要考虑了  如果观察者来不及反应的话 被观察者的执行时间会被拉长 有俩个解决办法 一个是使用多线程
一个是缓存

被观察者模式尽量要自己做主
在设计的时候要灵活考虑 否则就会加重观察者的处理逻辑

观察者模式又叫订阅发布模型
